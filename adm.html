<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>ADM – Lista da Pelada</title>

  <style>
    :root{
      --bg:#0f1216;--card:#141922;--txt:#e7edf6;--muted:#98a7be;
      --border:#222c3a;--ink:#0c1016;--accent:#25D366;--ok:#06d6a0;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;background:var(--bg);color:var(--txt)}
    .wrap{max-width:900px;margin:32px auto;padding:0 16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:20px;box-shadow:0 8px 30px rgba(0,0,0,.25)}

    h1{margin:0 0 10px;font-size:24px}
    .muted{color:var(--muted);margin-bottom:18px;font-size:14px}

    .row{display:flex;gap:20px;flex-wrap:wrap}
    .col{flex:1;min-width:300px}

    ul{list-style:none;padding:0;margin:0;display:grid;gap:8px}
    li{padding:10px 12px;border:1px solid var(--border);border-radius:12px;background:var(--ink);transition:all .20s;position:relative}

    li.is-new{border-color:var(--ok)}
    li.pending::after{
      content:"aguardando";position:absolute;right:12px;top:10px;
      font-size:11px;color:#8ee3c3;border:1px dashed #31785f;
      padding:2px 6px;border-radius:12px;
    }

    .btn{margin-top:12px;padding:12px 16px;width:100%;border:0;
         border-radius:12px;background:var(--accent);color:#0a0f0d;
         font-weight:700;font-size:16px;cursor:pointer}

    #resume{color:var(--muted);margin-top:14px;font-size:14px}
    #log{margin-top:10px;color:var(--muted);font-size:13px;min-height:18px}
  </style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <h1>Lista da Pelada – ADM</h1>
    <p class="muted">Os nomes aparecem imediatamente, e são confirmados assim que o CSV atualizar. Leituras parciais do Google são ignoradas para evitar “sobe-e-desce”.</p>

    <button id="btnWpp" class="btn">Enviar lista no WhatsApp</button>
    <div id="resume"></div>

    <div style="height:1px;background:var(--border);margin:18px 0"></div>

    <div class="row">
      <div class="col">
        <h3>Titulares (<span id="maxTit">15</span>)</h3>
        <ul id="tit"></ul>
      </div>
      <div class="col">
        <h3>Suplentes</h3>
        <ul id="sup"></ul>
      </div>
    </div>

    <div id="log"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="config.js"></script>

<script>
  // ======= CONFIG =======
  const cfg = window.PELADA_CFG || {};
  const CSV_URL = (cfg.SHEET_CSV_URL_NOMES || cfg.SHEET_CSV_URL || "").trim();
  const MAX_TIT = cfg.TITULARES_MAX ?? 15;
  const PRECO = cfg.PRECO || 20;

  // ======= ESTADO =======
  let ultimoNome = (sessionStorage.getItem('ultimo_nome_pelada')||'').toUpperCase() || null;

  // “snapshot estável” (o que mostramos em tela)
  let stableNames = [];
  let stableCorte = null;

  // para detectar leituras parciais/instáveis
  let lastFetchNames = [];
  let consecutiveGoodReads = 0; // quantas leituras “boas” seguidas recebemos

  // polling (após inserir)
  let pollTimer = null;
  let pollStart = null;

  // ======= HELPERS =======
  const normalize = s => (s||"").toString().trim().replace(/\s+/g,' ').toUpperCase();

  function parseDateAny(s){
    if(!s) return null;
    if(/^\d{2}\/\d{2}\/\d{4}/.test(s)){
      const [datePart, timePart=""] = s.split(/\s+/);
      const [d,m,y] = datePart.split('/').map(Number);
      let h=0,mi=0,se=0;
      if(timePart){ const t=timePart.split(':').map(Number); h=t[0]||0; mi=t[1]||0; se=t[2]||0; }
      return new Date(y, m-1, d, h, mi, se);
    }
    const t = Date.parse(s);
    return isNaN(t) ? null : new Date(t);
  }

  function lastTuesdayStart(d=new Date()){
    const dt=new Date(d.getFullYear(), d.getMonth(), d.getDate());
    const dow = dt.getDay(); // 0=Dom, 2=Ter
    const diff = (dow >= 2) ? dow-2 : (7 - (2-dow));
    dt.setDate(dt.getDate() - diff);
    dt.setHours(0,0,0,0);
    return dt;
  }

  function buildMsg(tit, sup, tot){
    const L=[];
    L.push("PELADA DE SEGUNDA ⚽\n");
    L.push("Titulares:");
    tit.forEach((n,i)=>L.push((i+1)+". "+n));
    L.push("\nSuplentes:");
    L.push(sup.length?sup.join(", "):"—");
    L.push("\nTotal de jogadores: "+tot);
    L.push("Valor arrecadado: R$ "+(tot*PRECO).toFixed(2).replace('.',','));
    return L.join("\n");
  }

  // ======= RENDER =======
  function renderLista(nomes, corte, highlight=null){
    const tit = document.getElementById('tit');
    const sup = document.getElementById('sup');
    tit.innerHTML=""; sup.innerHTML="";

    const titu = nomes.slice(0,MAX_TIT);
    const supl = nomes.slice(MAX_TIT);

    titu.forEach((n,i)=>{
      const li=document.createElement('li');
      li.textContent = (i+1)+"º — "+n;
      if(highlight && normalize(n)===normalize(highlight)) li.classList.add("is-new");
      if(/\(AGUARDANDO\)/i.test(n)) li.classList.add("pending");
      tit.appendChild(li);
    });
    supl.forEach((n,i)=>{
      const li=document.createElement('li');
      li.textContent = (i+1)+" — "+n;
      if(highlight && normalize(n)===normalize(highlight)) li.classList.add("is-new");
      if(/\(AGUARDANDO\)/i.test(n)) li.classList.add("pending");
      sup.appendChild(li);
    });

    document.getElementById('resume').innerHTML =
      `Total: <b>${nomes.length}</b> &nbsp;|&nbsp; 
       Arrecadado: <b>R$ ${(nomes.length*PRECO).toFixed(2).replace('.',',')}</b>`;

    window._wppMessage = buildMsg(titu, supl, nomes.length);
    document.getElementById("maxTit").textContent = MAX_TIT;
  }

  // ======= CSV =======
  async function fetchCSVText(){
    if(!CSV_URL) throw new Error("SHEET_CSV_URL (ou *_NOMES) não definido em config.js");
    const url = CSV_URL + (CSV_URL.includes('?')?'&':'?') + 'cacheBust=' + Date.now();
    const resp = await fetch(url, { cache:'no-store' });
    if(!resp.ok) throw new Error("Falha ao carregar CSV: " + resp.status);
    return resp.text();
  }

  function parseCSVToNames(csvText){
    const clean = csvText.replace(/^\uFEFF/, '');
    const parsed = Papa.parse(clean, {header:true, skipEmptyLines:true});
    const rows = parsed.data.map(r=>{
      const h = Object.keys(r);
      return {time:r[h[0]], name:normalize(r[h[1]])};
    }).filter(r=>r.name);

    const corte = lastTuesdayStart();
    const filtrados = rows
      .map(r=>({...r, date:parseDateAny(r.time)}))
      .filter(r=> r.date && r.date>=corte)
      .sort((a,b)=> a.date - b.date);

    return { names: filtrados.map(r=>r.name), corte };
  }

  // ======= ACEITAÇÃO / ESTABILIZAÇÃO =======
  // Regras:
  // - Se nova leitura for MUITO menor que a estável (queda > 30% OU > 5 nomes), consideramos "parcial" e ignoramos.
  // - Precisamos de 1 leitura “boa” para atualizar a estável (ou manter se igual/maior).
  function shouldAcceptSnapshot(newNames){
    if(stableNames.length === 0) return true; // primeira render
    const oldLen = stableNames.length;
    const newLen = newNames.length;

    const bigDrop = (oldLen - newLen) > 5 || (newLen < oldLen * 0.7);
    return !bigDrop;
  }

  async function loadOnceAndStabilize({highlight=null, optimistic=false}={}){
    try{
      const csv = await fetchCSVText();
      const {names, corte} = parseCSVToNames(csv);
      lastFetchNames = names;

      // Se for leitura “boa”, atualiza estável
      if(shouldAcceptSnapshot(names)){
        stableNames = names;
        stableCorte = corte;
        consecutiveGoodReads++;
        renderLista(stableNames, stableCorte, highlight);
        document.getElementById('log').textContent = "";
      } else {
        // Ignora leitura parcial: mantém a tela como está
        consecutiveGoodReads = 0;
        document.getElementById('log').textContent = "Ignorando leitura parcial do CSV (instável).";
      }

      // Se modo otimista (acabou de inserir) e não confirmou, injeta provisório
      if(optimistic && ultimoNome){
        const present = stableNames.includes(ultimoNome);
        if(!present){
          const withTmp = stableNames.slice();
          withTmp.push(`${ultimoNome} (aguardando)`);
          renderLista(withTmp, stableCorte || lastTuesdayStart(), null);
        }
      }

      return stableNames;
    }catch(err){
      console.error(err);
      document.getElementById('log').textContent = "Erro: " + err.message;
      return stableNames;
    }
  }

  // ======= FLUXO PRINCIPAL =======
  async function fluxoInicial(){
    // 1) carrega uma vez
    await loadOnceAndStabilize();

    // 2) se tem nome recém-enviado, modo otimista + polling
    if(ultimoNome){
      await loadOnceAndStabilize({ optimistic:true });

      pollStart = Date.now();
      pollTimer = setInterval(async ()=>{
        const names = await loadOnceAndStabilize();
        const ok = names.includes(ultimoNome);

        if(ok){
          clearInterval(pollTimer); pollTimer=null;
          sessionStorage.removeItem('ultimo_nome_pelada');
          renderLista(stableNames, stableCorte, ultimoNome); // destaque
